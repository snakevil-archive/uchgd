# repos/sample.auth: 范例版本库 sample 的权限配置。
#
# 【格式】
#
# 权限配置 = [ { [ 组定义 ] | 权限定义 } ] ;
#
# 组定义 = 组定义名称 , [ 空 ] , "=" , [ 空 ] , [ 用户列表 ] , EOL ;
#
# 权限定义 = 用户名称 , [ 空 ] , "=", [ 空 ] , 权限信息 , EOL ;
#
# 组定义名称 = "@" , { 可见字符 - "@" } ;
#
# 用户列表 = { ( 真实用户名称 | 组使用名称 ) , 空 } ;
#
# 用户名称 = 真实用户名称 | 组使用名称 | 伪用户 ;
#
# 权限信息 = 禁用权限 | 全写权限 | 可写分支列表 ;
#
# 真实用户名称 = 可见字符 - "%" , [ { 可见字符 } ] ;
#
# 组使用名称 = "%" , { 可见字符 } ;
#
# 伪用户 = 所有用户 ;
#
# 可写分支列表 = [ { 分支名称 , 空 } ] ;
#
# 分支名称 = { 可见字符 } ;
#
# 禁用权限 = "-" ;
#
# 全写权限 = "*" ;
#
# 所有用户 = "*" ;
#
# 可见字符 = ? 所有可见字符 ? ;
#
# 空 = ? 所有空白字符 ? - EOL ;
#
#
# 【所有用户】
#
# 『所有用户』用于定义版本库的基本权限。可视为 Linux 系统中的 Other 权限以便于理
# 解。
#
#
# 【组使用名称】
#
# 『组使用名称』用于定义特殊用户集合的版本库写权限。可视为 Linux 系统中的 Group
# 权限以便于理解。
#
# 但需要注意的是，组的使用是允许层叠。如：
#
# @biggroup = %smallgroup1 %smallgroup2
#
#
# 【禁写权限】
#
# 在某些情况下，版本库需要仅针对于指定的用户开放读写，就需要使用『禁写权限』来达
# 到这个目标。如：
#
# * = -
#
#
# 【全写权限】
#
# 在另外的一些情况下，需要有用户可以完全控制版本库，向任意一个分支进行操作。如版
# 本库的管理员就是一个典型。这个时候就需要使用『全写权限』来达到这个目标。如：
#
# * = *
#
#
# 【只读权限】
#
# 那么，如果需要某些用户可以访问版本库，但不允许向其中写入数据呢？可以使用一个为
# 空的『可写分支列表』来达到这个目标。如：
#
# * =

* = *
